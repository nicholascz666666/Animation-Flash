package cs3500.animator.controller;

import cs3500.animator.model.AnimatorModel;
import cs3500.animator.model.AnimatorModel.AnimeBuilder;
import cs3500.animator.model.IModel;
import cs3500.animator.model.KeyFrame;
import cs3500.animator.model.Shape;
import cs3500.animator.util.AnimationBuilder;
import cs3500.animator.view.IEditView;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Map;
import javax.swing.Timer;

/**
 * EditController implements the Features and AcitonListener. That would be enable the controller
 * itself as a actionlistener and could be repeatedy used {@Code actionPerformed}.
 */
public class EditController implements Features, ActionListener {

  private IModel model;
  private IEditView view;

  private int speed;
  private Timer timer;
  private int tick;
  private boolean loopable = true;
  private boolean pause = false;
  private int animationLength;

  /**
   * Constructor for editController.
   *
   * @param model inputted model for use
   */
  public EditController(IModel model) {
    this.model = model;
    this.speed = 2;
    this.tick = 0;
    this.animationLength = model.getAnimationLength();
  }

  /**
   * Set the edit view.
   *
   * @param view inputted edit view
   */
  public void setEditView(IEditView view) {
    this.view = view;
    this.timer = new Timer(1000 / speed, this);
    view.setPreferredSize(model.getBoundX(), model.getBoundY(),
        model.getWidth(), model.getHeight());
    view.addFeatures(this);
    view.setShapes(model.getHashShapes());
    view.getCurrentCMD();

    this.view.makeVisible();
  }


  @Override
  public void startAnimation() {
    this.timer.start();
  }

  @Override
  public void restartAnimation() {
    this.tick = 0;
    this.timer.restart();
  }

  @Override
  public void pauseAnimation() {

    if (!pause) {
      this.timer.stop();
    } else {
      this.timer.start();
    }
    pause = !pause;
  }

  @Override
  public void loopAnimation() {
    this.loopable = !loopable;
  }

  @Override
  public void fastAnimation() {
    this.speed = speed * 2;
    this.timer.stop();
    this.timer = new Timer(1000 / speed, this);
    this.timer.start();
  }

  @Override
  public void slowAnimation() {
    this.speed = speed / 2;
    this.timer.stop();
    this.timer = new Timer(1000 / speed, this);
    this.timer.start();
  }

  @Override
  public void addAnimation() {

    String choose = view.getCurrentCMD();
    String name = view.getInputName();

    switch (choose) {
      case "New Rectangle":
        editShape(null, name, "rectangle", null);
        break;
      case "New Oval":
        editShape(null, name, "ellipse", null);
        break;
      default:
        throw new IllegalArgumentException("Please enter choose one Shape");
    }

    view.setShapes(model.getHashShapes());

  }

  @Override
  public void deleteShape() {
    String deletename = view.getDeleteShape();
    editShape(null, "", "", deletename);
    view.setShapes(model.getHashShapes());
  }

  @Override
  public void editKeyFrame() {

    String name = view.getDeleteShape();
    ArrayList<Integer> frameValues = view.getNewFrameValues();

    editShape(frameValues, name, "", "");
    view.setShapes(model.getHashShapes());
  }

  @Override
  public void deleteKeyFrame() {

    String name = view.getDeleteShape();
    ArrayList<Integer> frameValues = view.getNewFrameValues();

    deleteFrame(frameValues.get(0), name);
    view.setShapes(model.getHashShapes());
  }

  @Override
  public void setSpeed(int speed) {
    this.speed = speed;
  }

  @Override
  public boolean getLoop() {
    return loopable;
  }

  @Override
  public boolean getPause() {
    return pause;
  }

  @Override
  public int getSpeed() {
    return speed;
  }

  /**
   * delete the frame based on the tick adn name.A new model would be generated by the deleteFrame
   * with all implemenation included.
   *
   * @param tick selected tick
   * @param name selected name
   */
  private void deleteFrame(int tick, String name) {
    Map<Shape, ArrayList<KeyFrame>> hashShapes = model.getHashShapes();

    AnimationBuilder<AnimatorModel> builder = new AnimeBuilder()
        .setBounds(model.getBoundX(), model.getBoundY(),
            model.getWidth(), model.getWidth());

    for (Shape shape : hashShapes.keySet()) {

      builder.declareShape(shape.getName(), shape.getType());
      for (KeyFrame frame : hashShapes.get(shape)) {

        if (shape.getName().equals(name) && frame.getT() == tick) {
          //do nothing
        } else {
          builder
              .addKeyframe(shape.getName(), frame.getT(), frame.getX(), frame.getY(),
                  frame.getW(),
                  frame.getH(), frame.getR(), frame.getG(), frame.getB());

        }
      }
    }

    this.model = builder.build();

  }

  /**
   * Modify the shape based on the tick adn name.A new model would be generated by the deleteFrame
   * with all implemenation included.
   *
   * @param frameValues inputted frameValues
   * @param name        inputtd name of shape
   * @param type        inputted type of shape
   * @param deleteName  The delete name
   */
  private void editShape(ArrayList<Integer> frameValues, String name, String type,
      String deleteName) {
    Map<Shape, ArrayList<KeyFrame>> hashShapes = model.getHashShapes();

    AnimationBuilder<AnimatorModel> builder = new AnimeBuilder()
        .setBounds(model.getBoundX(), model.getBoundY(),
            model.getWidth(), model.getWidth());

    for (Shape shape : hashShapes.keySet()) {

      if (!shape.getName().equals(deleteName)) {
        builder.declareShape(shape.getName(), shape.getType());
        for (KeyFrame frame : hashShapes.get(shape)) {

          builder
              .addKeyframe(shape.getName(), frame.getT(), frame.getX(), frame.getY(),
                  frame.getW(),
                  frame.getH(), frame.getR(), frame.getG(), frame.getB());

        }
      }
    }

    if (!type.equals("") && !name.equals("")) {
      builder.declareShape(name, type);
    }

    if (frameValues != null) {
      builder.addKeyframe(name, frameValues.get(0), frameValues.get(1), frameValues.get(2),
          frameValues.get(3), frameValues.get(4), frameValues.get(5), frameValues.get(6),
          frameValues.get(7));
    }

    this.model = builder.build();
  }

  @Override
  public void actionPerformed(ActionEvent e) {
    model.updateTick(tick);
    view.setUpdatedShapes(model.getShapes());
    view.refresh();
    this.view.makeVisible();
    tick++;

    if (loopable && tick > animationLength) {
      tick = 1;
    }

  }
}
